<!--
    Advanced GeoJSON Converter & Error Recovery Tool
    Copyright (C) 2025 GeoRoots
    
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
    
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fixer - GeoRoots</title>
    
    <style>
        /* CSS Variables for consistent color scheme */
        :root {
            --primary-color: #1b4332;
            --secondary-color: #40916c;
            --accent-color: #efffef;
            --dark-color: #1b4332;
            --light-color: #f8f9fa;
            --danger-color: #dc6575;
            --confirm-color: #40916c;
            --text-color: #333;
            --border-color: #e9ecef;
            --shadow-color: rgba(0, 0, 0, 0.1);
            
            /* Gray Scale */
            --gray-light: #f1f4f2;
            --gray-medium: #6c757d;
            --gray-dark: #495057;
            --gray-border: #e9ecef;
            --gray-input: #ddd;
            
            /* Basic Colors */
            --white: #ffffff;
            --black: #000000;
            
            /* Status Colors */
            --error-bg: #f8d7da;
            --error-border: #f5c6cb;
            --error-text: #721c24;
            --success-bg: #d4edda;
            --success-border: #c3e6cb;
            --success-text: #155724;
            --warning-bg: #fff3cd;
            --warning-border: #ffeaa7;
            --warning-text: #856404;
            
            /* Overlay and UI Colors */
            --modal-overlay: rgba(0, 0, 0, 0.7);
            --loading-overlay: rgba(0, 0, 0, 0.6);
            --spinner-bg: #f3f3f3;
            
            /* Hover States */
            --danger-hover: #d14a5a;
            --success-hover: #4a9f6b;
            --secondary-hover: #2d5a3d;
            
            /* Special Elements */
            --drop-border: #ccc;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: var(--text-color);
            background: var(--light-color);
            min-height: 100vh;
            line-height: 1.6;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--white);
            border-radius: 16px;
            box-shadow: 0 20px 60px var(--shadow-color);
            overflow: hidden;
        }

        .main-container {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: var(--secondary-color);
            color: white;
            padding: 20px;
            text-align: center;
            position: relative;
        }

        .language-selector {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .language-selector select {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 14px;
            cursor: pointer;
            backdrop-filter: blur(10px);
        }

        .language-selector select option {
            background: var(--white);
            color: var(--text-color);
        }

        .language-selector label {
            font-size: 14px;
            opacity: 0.9;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .header .small-print {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-top: 8px;
            line-height: 1.3;
        }

        .header .small-print a {
            color: var(--white);
            transition: color 0.3s ease;
        }

        .content-area {
            flex: 1;
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
        }

        .panel {
            background: var(--white);
            border-radius: 16px;
            box-shadow: 0 20px 60px var(--shadow-color);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            background: var(--gray-light);
            border-bottom: 1px solid var(--gray-border);
            padding: 15px 20px;
            font-weight: 600;
            color: var(--gray-dark);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .panel-content {
            flex: 1;
            padding: 20px;
            overflow: auto;
        }

        .file-drop-area {
            width: 100%;
            height: 200px;
            border: 3px dashed var(--drop-border);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
            padding: 20px;
            transition: all 0.3s ease;
            background-color: var(--gray-light);
            cursor: pointer;
        }

        .file-drop-area.is-active {
            border-color: var(--confirm-color);
            background-color: rgba(88, 183, 117, 0.1);
        }

        .file-drop-area.has-error {
            border-color: var(--danger-color);
            background-color: rgba(220, 101, 117, 0.1);
        }

        .upload-icon {
            font-size: 2rem;
            color: var(--gray-medium);
            margin-bottom: 1rem;
        }

        /* Enhanced JSON Editor with Line Numbers */
        .json-editor-container {
            position: relative;
            border: 1px solid var(--gray-input);
            border-radius: 6px;
            overflow: hidden;
            height: 400px;
            display: flex;
            background: var(--white);
        }

        .json-editor-container.has-error {
            border-color: var(--danger-color);
        }

        .line-numbers {
            background: var(--gray-light);
            border-right: 1px solid var(--gray-border);
            padding: 10px 8px 10px 12px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
            color: var(--gray-medium);
            text-align: right;
            user-select: none;
            min-width: 50px;
            overflow: hidden;
            white-space: pre;
            position: relative;
        }

        .json-editor {
            flex: 1;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            border: none;
            padding: 10px;
            resize: none;
            outline: none;
            line-height: 1.4;
            background: var(--white);
            overflow-y: auto;
            overflow-x: auto;
            white-space: pre;
            word-wrap: break-word;
            tab-size: 2;
        }

        .json-editor.has-error {
            background-color: rgba(220, 101, 117, 0.05);
        }

        /* Synchronized scrolling */
        .json-editor::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }

        .json-editor::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .json-editor::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 6px;
        }

        .json-editor::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        .error-message {
            background: var(--error-bg);
            color: var(--error-text);
            border: 1px solid var(--error-border);
            border-radius: 6px;
            padding: 10px;
            margin: 10px 0;
            font-size: 14px;
        }

        .success-message {
            background: var(--success-bg);
            color: var(--success-text);
            border: 1px solid var(--success-border);
            border-radius: 6px;
            padding: 10px;
            margin: 10px 0;
            font-size: 14px;
        }

        .warning-message {
            background: var(--warning-bg);
            color: var(--warning-text);
            border: 1px solid var(--warning-border);
            border-radius: 6px;
            padding: 10px;
            margin: 10px 0;
            font-size: 14px;
        }

        .btn {
            background: var(--confirm-color);
            color: var(--white);
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            text-decoration: none;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn-success {
            background: var(--confirm-color);
        }

        .btn-success:hover {
            background: var(--success-hover);
            box-shadow: 0 4px 12px rgba(74, 159, 107, 0.3);
        }

        .btn-danger {
            background: var(--danger-color);
        }

        .btn-danger:hover {
            background: var(--danger-hover);
            box-shadow: 0 4px 12px rgba(231, 76, 60, 0.3);
        }

        .btn-secondary {
            background: var(--gray-medium);
        }

        .btn-secondary:hover {
            background: var(--gray-dark);
            box-shadow: 0 4px 12px rgba(108, 117, 125, 0.3);
        }

        .static-fields {
            margin-bottom: 20px;
        }

        .static-field-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }

        .static-field-row select,
        .static-field-row input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid var(--gray-input);
            border-radius: 4px;
            font-size: 14px;
        }

        .static-field-row button {
            padding: 8px 12px;
            background: var(--danger-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .property-mapping {
            margin-bottom: 20px;
        }

        .property-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
            padding: 10px;
            background: var(--gray-light);
            border-radius: 6px;
        }

        .property-row input,
        .property-row select {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid var(--gray-input);
            border-radius: 4px;
            font-size: 14px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: var(--gray-light);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid var(--gray-border);
        }

        .stat-number {
            font-size: 2rem;
            font-weight: 700;
            color: var(--confirm-color);
            display: block;
        }

        .stat-label {
            font-size: 0.9rem;
            color: var(--gray-medium);
            margin-top: 5px;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--loading-overlay);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 999;
            flex-direction: column;
            color: white;
        }

        .loading-overlay.show {
            display: flex;
        }

        .loading-spinner {
            border: 8px solid var(--spinner-bg);
            border-top: 8px solid var(--confirm-color);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .processing-options {
            margin-left: 20px;
            margin-top: 10px;
        }

        .processing-options label {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .processing-options input[type="checkbox"] {
            margin: 0;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: var(--gray-border);
            border-radius: 3px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: var(--confirm-color);
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Large screens */
        @media (min-width: 1200px) {
            .content-area {
                grid-template-columns: 1fr 1fr;
                gap: 30px;
            }
        }

        /* Medium screens */
        @media (max-width: 1024px) {
            body {
                padding: 10px;
            }
            
            .content-area {
                grid-template-columns: 1fr;
                gap: 10px;
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .header {
                padding: 15px;
            }
        }

        /* Small screens */
        @media (max-width: 768px) {
            body {
                padding: 5px;
            }
            
            .header {
                padding: 20px 15px 15px 15px;
            }
            
            .header h1 {
                font-size: 1.8rem;
            }
            
            .header p {
                font-size: 1rem;
            }
            
            .language-selector {
                position: static;
                justify-content: center;
                margin-bottom: 15px;
            }
            
            /* Touch-friendly targets */
            .btn {
                min-height: 44px;
                padding: 12px 24px;
            }
            
            .file-drop-area {
                min-height: 120px;
            }
        }

        /* Very small screens */
        @media (max-width: 480px) {
            .header h1 {
                font-size: 1.5rem;
            }
            
            .header p {
                font-size: 0.9rem;
            }
            
            .file-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            
            .file-info {
                width: 100%;
                overflow: hidden;
            }
            
            .file-name {
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            
            .remove-file {
                align-self: flex-end;
                min-height: 44px;
                min-width: 44px;
            }
            
            /* Stack buttons vertically */
            .button-group {
                flex-direction: column;
            }
            
            .button-group .btn {
                width: 100%;
                justify-content: center;
            }
        }

        .syntax-highlight {
            background: var(--gray-light);
            border: 1px solid var(--gray-border);
            border-radius: 6px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
            white-space: pre-wrap;
            overflow-x: auto;
            max-height: 400px;
            overflow-y: auto;
        }

        .json-string { color: #008000; }
        .json-number { color: #0000ff; }
        .json-boolean { color: #ff6600; }
        .json-null { color: #ff6600; }
        .json-key { color: #8b0000; font-weight: bold; }
        .json-error { background-color: #ffcccc; color: #cc0000; font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-container">
            <div class="header">
            <div class="language-selector">
                <label for="languageSelect" aria-label="Select language">üåê</label>
                <select id="languageSelect" aria-label="Language selection">
                    <option value="en">English</option>
                    <option value="es">Espa√±ol</option>
                    <option value="pt">Portugu√™s</option>
                </select>
            </div>
            <h1 data-i18n="title">GeoRoots Fixer</h1>
            <p data-i18n="subtitle">Advanced GeoJSON Converter & Error Recovery Tool</p>
            <p data-i18n="privacy" class="small-print">Your file and any of its content is only processed locally in your browser and none of your information is sent to anyone else.</p>
            <p data-i18n="license" class="small-print">This software is free, released under GPLv3 open source license.</p>
                            <p class="small-print"><span data-i18n="downloadLatest">Download latest version and other tools on</span> <a href="https://georoots.eu/" target="_blank">https://georoots.eu/</a></p>
        </div>

        <div class="content-area">
            <!-- Input Panel -->
            <div class="panel">
                <div class="panel-header">
                    üì§
                    <span data-i18n="inputEditor">Input & Editor</span>
                </div>
                <div class="panel-content">
                    <div class="file-drop-area" id="dropArea">
                        <div class="upload-icon">
                            <svg width="48" height="48" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/>
                                <path d="M12,12L16,16H13.5V19H10.5V16H8L12,12Z"/>
                            </svg>
                        </div>
                        <p data-i18n="dropFile">Drop your GeoJSON/JSON file here</p>
                        <p data-i18n="orClickBrowse">or click to browse</p>
                        <input type="file" id="fileInput" accept=".json,.geojson" style="display: none;" aria-label="Upload GeoJSON file">
                    </div>

                    <div id="errorMessages"></div>

                    <div id="editorSection">
                        <div>
                            <label>
                                üìù <span data-i18n="jsonEditor">JSON Editor</span>
                            </label>
                            <div class="json-editor-container" id="jsonEditorContainer">
                                <div class="line-numbers" id="lineNumbers">1</div>
                                <textarea id="jsonEditor" class="json-editor" data-i18n-placeholder="jsonEditorPlaceholder" autocomplete="off"></textarea>
                            </div>
                        </div>
                        
                        <div class="button-group">
                            <button id="validateBtn" class="btn">
                                ‚úîÔ∏è <span data-i18n="validateJSON">Validate JSON</span>
                            </button>
                            <button id="fixBtn" class="btn btn-secondary">
                                üîß <span data-i18n="autoFixIssues">Auto-Fix Common Issues</span>
                            </button>
                            <button id="formatBtn" class="btn btn-secondary">
                                üìÑ <span data-i18n="formatJSON">Format JSON</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Processing Panel -->
            <div class="panel">
                <div class="panel-header">
                    ‚öôÔ∏è
                    <span data-i18n="processingConfig">Processing & Configuration</span>
                </div>
                <div class="panel-content">
                    <div id="fileStats">
                        <div class="stats">
                            <div class="stat-card">
                                <span id="featureCount" class="stat-number">0</span>
                                <div class="stat-label" data-i18n="features">Features</div>
                            </div>
                            <div class="stat-card">
                                <span id="polygonCount" class="stat-number">0</span>
                                <div class="stat-label" data-i18n="polygons">Polygons</div>
                            </div>
                            <div class="stat-card">
                                <span id="multiPolygonCount" class="stat-number">0</span>
                                <div class="stat-label" data-i18n="multiPolygons">MultiPolygons</div>
                            </div>
                            <div class="stat-card">
                                <span id="pointCount" class="stat-number">0</span>
                                <div class="stat-label" data-i18n="points">Points</div>
                            </div>
                            <div class="stat-card">
                                <span id="errorCount" class="stat-number">0</span>
                                <div class="stat-label" data-i18n="errors">Errors</div>
                            </div>
                        </div>
                    </div>

                    <div id="staticFields" class="static-fields">
                        <h4>
                            üíæ <span data-i18n="staticFieldValues">Static Field Values</span>
                        </h4>
                        <div id="staticFieldsList"></div>
                        <button id="addStaticField" class="btn btn-secondary">
                            ‚ûï <span data-i18n="addStaticField">Add Static Field</span>
                        </button>
                    </div>

                    <div id="propertyMapping" class="property-mapping">
                        <h4>
                            üîÅ <span data-i18n="propertyMapping">Property Mapping</span>
                        </h4>
                        <div id="propertyList"></div>
                    </div>

                    <div id="processingOptions">
                        <h4>
                            ‚öôÔ∏è <span data-i18n="processingOptions">Processing Options</span>
                        </h4>
                        <div class="processing-options">
                            <label>
                                <input type="checkbox" id="splitMultiPolygons" checked>
                                <span data-i18n="splitMultiPolygons">Split MultiPolygons into separate Polygon features</span>
                            </label>
                            <label>
                                <input type="checkbox" id="validateGeometry" checked>
                                <span data-i18n="validateGeometry">Validate and fix geometry issues</span>
                            </label>
                            <label>
                                <input type="checkbox" id="roundCoordinates">
                                <span data-i18n="roundCoordinates">Round coordinates to 6 decimals</span>
                            </label>
                            <label>
                                <input type="checkbox" id="removeWhitespace">
                                <span data-i18n="removeWhitespace">Remove whitespace to shrink file size</span>
                            </label>
                        </div>
                    </div>

                    <div id="actionButtons" class="button-group">
                        <button id="processBtn" class="btn btn-success">
                            ‚ñ∂Ô∏è <span data-i18n="processGeoJSON">Process GeoJSON</span>
                        </button>
                        <button id="resetBtn" class="btn btn-danger">
                            üîÑ <span data-i18n="reset">Reset</span>
                        </button>
                    </div>

                    <div class="progress-bar" id="progressBar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                </div>
            </div>
            </div>
        </div>
    </div>

    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
        <p data-i18n="processingMessage">Processing your GeoJSON...</p>
    </div>

    <script>
        // Translation system
        const translations = {
            en: {
                title: "GeoRoots Fixer",
                subtitle: "Advanced GeoJSON Converter & Error Recovery Tool",
                privacy: "Your file and any of its content is only processed locally in your browser and none of your information is sent to anyone else.",
                license: "This software is free, released under GPLv3 open source license.",
                inputEditor: "Input & Editor",
                processingConfig: "Processing & Configuration",
                dropFile: "Drop your GeoJSON/JSON file here",
                orClickBrowse: "or click to browse",
                jsonEditor: "JSON Editor",
                validateJSON: "Validate JSON",
                autoFixIssues: "Auto-Fix Common Issues",
                formatJSON: "Format JSON",
                features: "Features",
                polygons: "Polygons",
                multiPolygons: "MultiPolygons",
                points: "Points",
                errors: "Errors",
                staticFieldValues: "Static Field Values",
                addStaticField: "Add Static Field",
                propertyMapping: "Property Mapping",
                processingOptions: "Processing Options",
                splitMultiPolygons: "Split MultiPolygons into separate Polygon features",
                validateGeometry: "Fix basic geometry issues (ring closing, winding order)",
                processGeoJSON: "Process & Download GeoJSON",
                downloadResult: "Download Result",
                reset: "Reset",
                processingMessage: "Processing your GeoJSON...",
                selectField: "Select field",
                customField: "Custom field...",
                staticValue: "Static value",
                discardPropertyInformation: "Discard Property Information",
                leaveAsIs: "Leave as is",
                customFieldName: "Custom field name...",
                roundCoordinates: "Round coordinates to 6 decimals",
                removeWhitespace: "Remove whitespace to shrink file size",
                pleaseProvideJSON: "Please provide JSON content",
                jsonValid: "JSON is valid!",
                jsonFormattedSuccess: "JSON formatted successfully!",
                failedToReadFile: "Failed to read file: ",
                cannotFormatInvalidJSON: "Cannot format invalid JSON. Please fix errors first.",
                noValidDataToProcess: "No valid data to process",
                processingFailed: "Processing failed: ",
                noProcessedDataToDownload: "No processed data to download",
                successfullyProcessed: "Successfully processed ",
                featuresCount: " features!",
                jsonEditorPlaceholder: "Paste your JSON/GeoJSON here...",
                autoFixSuccess: "Auto-fix completed successfully!",
                autoFixFailed: "Auto-fix failed. Original text preserved. Please fix manually.",
                fileTooLarge: "File is too large. Maximum size is 10MB.",
                invalidGeoJSON: "Invalid GeoJSON structure",
                invalidGeoJSONStructure: "Invalid GeoJSON structure",
                missingTypeField: "Missing 'type' field",
                invalidTypeField: "Invalid 'type' field",
                invalidFeaturesArray: "Invalid 'features' array",
                invalidFeature: "Invalid feature",
                invalidFeatureType: "Invalid feature type",
                missingGeometry: "Missing geometry",
                invalidGeometry: "Invalid geometry",
                missingGeometryType: "Missing geometry type",
                missingCoordinates: "Missing coordinates",
                invalidGeometryType: "Invalid geometry type",
                coordinatesMustBeArray: "Coordinates must be an array",
                invalidPointCoordinates: "Invalid point coordinates",
                invalidCoordinateValues: "Invalid coordinate values",
                invalidLineStringCoordinates: "Invalid LineString coordinates",
                invalidCoordinateArray: "Invalid coordinate array",
                invalidPolygonCoordinates: "Invalid polygon coordinates",
                invalidPolygonRing: "Invalid polygon ring",
                invalidMultiGeometryCoordinates: "Invalid multi-geometry coordinates",
                downloadLatest: "Download latest version and other tools on"
            },
            es: {
                title: "GeoRoots Fixer",
                subtitle: "Herramienta Avanzada de Conversi√≥n y Recuperaci√≥n de Errores GeoJSON",
                privacy: "Tu archivo y todo su contenido se procesa √∫nicamente localmente en tu navegador y ninguna de tu informaci√≥n se env√≠a a nadie m√°s.",
                license: "Este software es gratuito, liberado bajo licencia de c√≥digo abierto GPLv3.",
                inputEditor: "Entrada y Editor",
                processingConfig: "Procesamiento y Configuraci√≥n",
                dropFile: "Suelta tu archivo GeoJSON/JSON aqu√≠",
                orClickBrowse: "o haz clic para explorar",
                jsonEditor: "Editor JSON",
                validateJSON: "Validar JSON",
                autoFixIssues: "Auto-corregir Problemas Comunes",
                formatJSON: "Formatear JSON",
                features: "Caracter√≠sticas",
                polygons: "Pol√≠gonos",
                multiPolygons: "MultiPol√≠gonos",
                points: "Puntos",
                errors: "Errores",
                staticFieldValues: "Valores de Campo Est√°tico",
                addStaticField: "Agregar Campo Est√°tico",
                propertyMapping: "Mapeo de Propiedades",
                processingOptions: "Opciones de Procesamiento",
                splitMultiPolygons: "Dividir MultiPol√≠gonos en caracter√≠sticas de Pol√≠gono separadas",
                validateGeometry: "Corregir problemas b√°sicos de geometr√≠a (cierre de anillos, orden de bobinado)",
                processGeoJSON: "Procesar y Descargar GeoJSON",
                downloadResult: "Descargar Resultado",
                reset: "Reiniciar",
                processingMessage: "Procesando tu GeoJSON...",
                selectField: "Seleccionar campo",
                customField: "Campo personalizado...",
                staticValue: "Valor est√°tico",
                discardPropertyInformation: "Descartar Informaci√≥n de Propiedad",
                leaveAsIs: "Dejar como est√°",
                customFieldName: "Nombre de campo personalizado...",
                roundCoordinates: "Redondear coordenadas a 6 decimales",
                removeWhitespace: "Eliminar espacios en blanco para reducir el tama√±o del archivo",
                pleaseProvideJSON: "Por favor proporciona contenido JSON",
                jsonValid: "¬°JSON es v√°lido!",
                jsonFormattedSuccess: "¬°JSON formateado exitosamente!",
                failedToReadFile: "Error al leer archivo: ",
                cannotFormatInvalidJSON: "No se puede formatear JSON inv√°lido. Por favor corrige los errores primero.",
                noValidDataToProcess: "No hay datos v√°lidos para procesar",
                processingFailed: "El procesamiento fall√≥: ",
                noProcessedDataToDownload: "No hay datos procesados para descargar",
                successfullyProcessed: "Procesado exitosamente ",
                featuresCount: " caracter√≠sticas!",
                jsonEditorPlaceholder: "Pega tu JSON/GeoJSON aqu√≠...",
                autoFixSuccess: "¬°Auto-correcci√≥n completada exitosamente!",
                autoFixFailed: "Auto-correcci√≥n fall√≥. Texto original preservado. Por favor corrige manualmente.",
                fileTooLarge: "El archivo es demasiado grande. Tama√±o m√°ximo es 10MB.",
                invalidGeoJSON: "Estructura GeoJSON inv√°lida",
                invalidGeoJSONStructure: "Estructura GeoJSON inv√°lida",
                missingTypeField: "Campo 'type' faltante",
                invalidTypeField: "Campo 'type' inv√°lido",
                invalidFeaturesArray: "Array 'features' inv√°lido",
                invalidFeature: "Caracter√≠stica inv√°lida",
                invalidFeatureType: "Tipo de caracter√≠stica inv√°lido",
                missingGeometry: "Geometr√≠a faltante",
                invalidGeometry: "Geometr√≠a inv√°lida",
                missingGeometryType: "Tipo de geometr√≠a faltante",
                missingCoordinates: "Coordenadas faltantes",
                invalidGeometryType: "Tipo de geometr√≠a inv√°lido",
                coordinatesMustBeArray: "Las coordenadas deben ser un array",
                invalidPointCoordinates: "Coordenadas de punto inv√°lidas",
                invalidCoordinateValues: "Valores de coordenadas inv√°lidos",
                invalidLineStringCoordinates: "Coordenadas de LineString inv√°lidas",
                invalidCoordinateArray: "Array de coordenadas inv√°lido",
                invalidPolygonCoordinates: "Coordenadas de pol√≠gono inv√°lidas",
                invalidPolygonRing: "Anillo de pol√≠gono inv√°lido",
                invalidMultiGeometryCoordinates: "Coordenadas de multi-geometr√≠a inv√°lidas",
                downloadLatest: "Descarga la √∫ltima versi√≥n y otras herramientas en"
            },
            pt: {
                title: "GeoRoots Fixer",
                subtitle: "Ferramenta Avan√ßada de Convers√£o e Recupera√ß√£o de Erros GeoJSON",
                privacy: "Seu arquivo e todo seu conte√∫do √© processado apenas localmente no seu navegador e nenhuma de suas informa√ß√µes √© enviada para ningu√©m mais.",
                license: "Este software √© gratuito, liberado sob licen√ßa de c√≥digo aberto GPLv3.",
                inputEditor: "Entrada e Editor",
                processingConfig: "Processamento e Configura√ß√£o",
                dropFile: "Solte seu arquivo GeoJSON/JSON aqui",
                orClickBrowse: "ou clique para navegar",
                jsonEditor: "Editor JSON",
                validateJSON: "Validar JSON",
                autoFixIssues: "Auto-corrigir Problemas Comuns",
                formatJSON: "Formatar JSON",
                features: "Caracter√≠sticas",
                polygons: "Pol√≠gonos",
                multiPolygons: "MultiPol√≠gonos",
                points: "Pontos",
                errors: "Erros",
                staticFieldValues: "Valores de Campo Est√°tico",
                addStaticField: "Adicionar Campo Est√°tico",
                propertyMapping: "Mapeamento de Propriedades",
                processingOptions: "Op√ß√µes de Processamento",
                splitMultiPolygons: "Dividir MultiPol√≠gonos em caracter√≠sticas de Pol√≠gono separadas",
                validateGeometry: "Corrigir problemas b√°sicos de geometria (fechamento de an√©is, ordem de enrolamento)",
                processGeoJSON: "Processar e Baixar GeoJSON",
                downloadResult: "Baixar Resultado",
                reset: "Reiniciar",
                processingMessage: "Processando seu GeoJSON...",
                selectField: "Selecionar campo",
                customField: "Campo personalizado...",
                staticValue: "Valor est√°tico",
                discardPropertyInformation: "Descartar Informa√ß√£o da Propriedade",
                leaveAsIs: "Deixar como est√°",
                customFieldName: "Nome do campo personalizado...",
                roundCoordinates: "Arredondar coordenadas para 6 decimais",
                removeWhitespace: "Remover espa√ßos em branco para reduzir o tamanho do arquivo",
                pleaseProvideJSON: "Por favor forne√ßa conte√∫do JSON",
                jsonValid: "JSON √© v√°lido!",
                jsonFormattedSuccess: "JSON formatado com sucesso!",
                failedToReadFile: "Falha ao ler arquivo: ",
                cannotFormatInvalidJSON: "N√£o √© poss√≠vel formatar JSON inv√°lido. Por favor corrija os erros primeiro.",
                noValidDataToProcess: "N√£o h√° dados v√°lidos para processar",
                processingFailed: "O processamento falhou: ",
                noProcessedDataToDownload: "N√£o h√° dados processados para baixar",
                successfullyProcessed: "Processado com sucesso ",
                featuresCount: " caracter√≠sticas!",
                jsonEditorPlaceholder: "Cole seu JSON/GeoJSON aqui...",
                autoFixSuccess: "Auto-corre√ß√£o conclu√≠da com sucesso!",
                autoFixFailed: "Auto-corre√ß√£o falhou. Texto original preservado. Por favor corrija manualmente.",
                fileTooLarge: "O arquivo √© muito grande. Tamanho m√°ximo √© 10MB.",
                invalidGeoJSON: "Estrutura GeoJSON inv√°lida",
                invalidGeoJSONStructure: "Estrutura GeoJSON inv√°lida",
                missingTypeField: "Campo 'type' ausente",
                invalidTypeField: "Campo 'type' inv√°lido",
                invalidFeaturesArray: "Array 'features' inv√°lido",
                invalidFeature: "Caracter√≠stica inv√°lida",
                invalidFeatureType: "Tipo de caracter√≠stica inv√°lido",
                missingGeometry: "Geometria ausente",
                invalidGeometry: "Geometria inv√°lida",
                missingGeometryType: "Tipo de geometria ausente",
                missingCoordinates: "Coordenadas ausentes",
                invalidGeometryType: "Tipo de geometria inv√°lido",
                coordinatesMustBeArray: "As coordenadas devem ser um array",
                invalidPointCoordinates: "Coordenadas de ponto inv√°lidas",
                invalidCoordinateValues: "Valores de coordenadas inv√°lidos",
                invalidLineStringCoordinates: "Coordenadas de LineString inv√°lidas",
                invalidCoordinateArray: "Array de coordenadas inv√°lido",
                invalidPolygonCoordinates: "Coordenadas de pol√≠gono inv√°lidas",
                invalidPolygonRing: "Anel de pol√≠gono inv√°lido",
                invalidMultiGeometryCoordinates: "Coordenadas de multi-geometria inv√°lidas",
                downloadLatest: "Baixe a vers√£o mais recente e outras ferramentas em"
            }
        };

        class GeoJSONConverter {
            constructor() {
                this.rawData = null;
                this.processedData = null;
                this.errors = [];
                this.warnings = [];
                this.staticFields = new Map();
                this.propertyMappings = new Map();
                this.discardedProperties = new Set();
                this.currentLanguage = 'en';
                this.eventListeners = new Map(); // Track event listeners for cleanup
                this.validateTimeout = null; // Initialize validation timeout
                this.initializeEventListeners();
                this.updateLineNumbers();
                this.initializeLanguage();
            }

            initializeEventListeners() {
                const dropArea = document.getElementById('dropArea');
                const fileInput = document.getElementById('fileInput');
                const jsonEditor = document.getElementById('jsonEditor');

                // File upload handlers
                this.addEventListener(dropArea, 'click', () => fileInput.click());
                this.addEventListener(dropArea, 'dragover', this.handleDragOver.bind(this));
                this.addEventListener(dropArea, 'dragleave', this.handleDragLeave.bind(this));
                this.addEventListener(dropArea, 'drop', this.handleDrop.bind(this));
                this.addEventListener(fileInput, 'change', this.handleFileSelect.bind(this));

                // Editor handlers
                this.addEventListener(jsonEditor, 'input', this.handleEditorChange.bind(this));
                this.addEventListener(jsonEditor, 'scroll', this.syncLineNumbersScroll.bind(this));
                this.addEventListener(jsonEditor, 'keydown', this.handleEditorKeydown.bind(this));
                this.addEventListener(jsonEditor, 'paste', () => {
                    setTimeout(() => this.updateLineNumbers(), 0);
                });

                // Button handlers
                this.addEventListener(document.getElementById('validateBtn'), 'click', this.validateJSON.bind(this));
                this.addEventListener(document.getElementById('fixBtn'), 'click', this.autoFixJSON.bind(this));
                this.addEventListener(document.getElementById('formatBtn'), 'click', this.formatJSON.bind(this));
                this.addEventListener(document.getElementById('processBtn'), 'click', this.processGeoJSON.bind(this));
                this.addEventListener(document.getElementById('resetBtn'), 'click', this.reset.bind(this));
                this.addEventListener(document.getElementById('addStaticField'), 'click', this.addStaticField.bind(this));

                // Language selector
                this.addEventListener(document.getElementById('languageSelect'), 'change', this.changeLanguage.bind(this));
            }

            addEventListener(element, event, handler) {
                element.addEventListener(event, handler);
                const key = `${element.id || 'unknown'}_${event}`;
                if (!this.eventListeners.has(key)) {
                    this.eventListeners.set(key, []);
                }
                this.eventListeners.get(key).push({ element, event, handler });
            }

            removeEventListeners() {
                this.eventListeners.forEach((listeners, key) => {
                    listeners.forEach(({ element, event, handler }) => {
                        element.removeEventListener(event, handler);
                    });
                });
                this.eventListeners.clear();
            }

            initializeLanguage() {
                // Set default language or load from localStorage
                const savedLanguage = localStorage.getItem('preferredLanguage') || 'en';
                document.getElementById('languageSelect').value = savedLanguage;
                this.currentLanguage = savedLanguage;
                this.updateTranslations();
            }

            changeLanguage(event) {
                this.currentLanguage = event.target.value;
                localStorage.setItem('preferredLanguage', this.currentLanguage);
                this.updateTranslations();
            }

            updateTranslations() {
                const elements = document.querySelectorAll('[data-i18n]');
                elements.forEach(element => {
                    const key = element.getAttribute('data-i18n');
                    const translation = translations[this.currentLanguage][key];
                    if (translation) {
                        element.textContent = translation;
                    }
                });

                // Handle placeholder translations
                const placeholderElements = document.querySelectorAll('[data-i18n-placeholder]');
                placeholderElements.forEach(element => {
                    const key = element.getAttribute('data-i18n-placeholder');
                    const translation = translations[this.currentLanguage][key];
                    if (translation) {
                        element.placeholder = translation;
                    }
                });
            }

            updateLineNumbers() {
                const editor = document.getElementById('jsonEditor');
                const lineNumbers = document.getElementById('lineNumbers');
                
                // Count lines without creating array - more memory efficient
                let lineCount = 1;
                for (let i = 0; i < editor.value.length; i++) {
                    if (editor.value[i] === '\n') lineCount++;
                }
                
                // Build line numbers more efficiently using array join
                const lineNumbersArray = [];
                for (let i = 1; i <= lineCount; i++) {
                    lineNumbersArray.push(i);
                }
                
                lineNumbers.textContent = lineNumbersArray.join('\n');
                
                // Sync scroll position
                this.syncLineNumbersScroll();
            }

            syncLineNumbersScroll() {
                const editor = document.getElementById('jsonEditor');
                const lineNumbers = document.getElementById('lineNumbers');
                lineNumbers.scrollTop = editor.scrollTop;
            }

            handleEditorKeydown(e) {
                const editor = document.getElementById('jsonEditor');
                
                // Handle Tab key for proper indentation
                if (e.key === 'Tab') {
                    e.preventDefault();
                    const start = editor.selectionStart;
                    const end = editor.selectionEnd;
                    
                    // Insert 2 spaces instead of tab
                    editor.value = editor.value.substring(0, start) + '  ' + editor.value.substring(end);
                    editor.selectionStart = editor.selectionEnd = start + 2;
                    
                    this.updateLineNumbers();
                }
                
                // Update line numbers on Enter key and other keys that might change line count
                if (e.key === 'Enter' || e.key === 'Backspace' || e.key === 'Delete') {
                    setTimeout(() => this.updateLineNumbers(), 0);
                }
            }

            handleDragOver(e) {
                e.preventDefault();
                document.getElementById('dropArea').classList.add('is-active');
            }

            handleDragLeave(e) {
                e.preventDefault();
                document.getElementById('dropArea').classList.remove('is-active');
            }

            handleDrop(e) {
                e.preventDefault();
                document.getElementById('dropArea').classList.remove('is-active');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    this.loadFile(files[0]);
                }
            }

            handleFileSelect(e) {
                const files = e.target.files;
                if (files.length > 0) {
                    this.loadFile(files[0]);
                }
            }

            async loadFile(file) {
                try {
                    // File size validation (10MB limit)
                    const maxSize = 1000 * 1024 * 1024; // 10MB
                    if (file.size > maxSize) {
                        this.showError(this.getTranslation('fileTooLarge'));
                        return;
                    }

                    const text = await file.text();
                    document.getElementById('jsonEditor').value = text;
                    this.updateLineNumbers();
                    this.showEditor();
                    this.validateJSON();
                } catch (error) {
                    this.showError(this.getTranslation('failedToReadFile') + error.message);
                }
            }

            showEditor() {
                document.getElementById('editorSection').classList.remove('hidden');
                document.getElementById('staticFields').classList.remove('hidden');
                document.getElementById('processingOptions').classList.remove('hidden');
                document.getElementById('actionButtons').classList.remove('hidden');
            }

            validateJSON() {
                const editor = document.getElementById('jsonEditor');
                const container = document.getElementById('jsonEditorContainer');
                const text = editor.value.trim();
                
                if (!text) {
                    this.showError(this.getTranslation('pleaseProvideJSON'));
                    return false;
                }

                try {
                    // Try to parse the JSON
                    const parsed = JSON.parse(text);
                    
                    // Validate GeoJSON structure
                    const geoJSONValidation = this.validateGeoJSONStructure(parsed);
                    if (!geoJSONValidation.isValid) {
                        this.showError(this.getTranslation('invalidGeoJSON') + ': ' + geoJSONValidation.error);
                        container.classList.add('has-error');
                        editor.classList.add('has-error');
                        return false;
                    }
                    
                    this.rawData = parsed;
                    this.clearErrors();
                    this.showSuccess(this.getTranslation('jsonValid'));
                    this.analyzeData();
                    container.classList.remove('has-error');
                    editor.classList.remove('has-error');
                    return true;
                } catch (error) {
                    // Handle JSON parsing errors
                    this.handleJSONError(error, text);
                    container.classList.add('has-error');
                    editor.classList.add('has-error');
                    return false;
                }
            }

            validateGeoJSONStructure(data) {
                // Check if it's a valid GeoJSON structure
                if (!data || typeof data !== 'object') {
                    return { isValid: false, error: this.getTranslation('invalidGeoJSONStructure') };
                }

                // Check for required type field
                if (!data.type) {
                    return { isValid: false, error: this.getTranslation('missingTypeField') };
                }

                const validTypes = ['Feature', 'FeatureCollection', 'Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon', 'GeometryCollection'];
                if (!validTypes.includes(data.type)) {
                    return { isValid: false, error: this.getTranslation('invalidTypeField') };
                }

                // Validate FeatureCollection
                if (data.type === 'FeatureCollection') {
                    if (!Array.isArray(data.features)) {
                        return { isValid: false, error: this.getTranslation('invalidFeaturesArray') };
                    }
                    
                    // Validate only first 100 features for large datasets to save memory/time
                    const featuresToValidate = Math.min(data.features.length, 100);
                    for (let i = 0; i < featuresToValidate; i++) {
                        const feature = data.features[i];
                        if (!feature || typeof feature !== 'object') {
                            return { isValid: false, error: this.getTranslation('invalidFeature') + ` at index ${i}` };
                        }
                        if (feature.type !== 'Feature') {
                            return { isValid: false, error: this.getTranslation('invalidFeatureType') + ` at index ${i}` };
                        }
                        if (!feature.geometry) {
                            return { isValid: false, error: this.getTranslation('missingGeometry') + ` at index ${i}` };
                        }
                        
                        const geometryValidation = this.validateGeometry(feature.geometry);
                        if (!geometryValidation.isValid) {
                            return { isValid: false, error: geometryValidation.error + ` at index ${i}` };
                        }
                    }
                }

                // Validate single Feature
                if (data.type === 'Feature') {
                    if (!data.geometry) {
                        return { isValid: false, error: this.getTranslation('missingGeometry') };
                    }
                    
                    const geometryValidation = this.validateGeometry(data.geometry);
                    if (!geometryValidation.isValid) {
                        return { isValid: false, error: geometryValidation.error };
                    }
                }

                // Validate raw geometry
                if (['Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon'].includes(data.type)) {
                    const geometryValidation = this.validateGeometry(data);
                    if (!geometryValidation.isValid) {
                        return { isValid: false, error: geometryValidation.error };
                    }
                }

                return { isValid: true };
            }

            validateGeometry(geometry) {
                if (!geometry || typeof geometry !== 'object') {
                    return { isValid: false, error: this.getTranslation('invalidGeometry') };
                }

                if (!geometry.type) {
                    return { isValid: false, error: this.getTranslation('missingGeometryType') };
                }

                if (!geometry.coordinates) {
                    return { isValid: false, error: this.getTranslation('missingCoordinates') };
                }

                const validTypes = ['Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon'];
                if (!validTypes.includes(geometry.type)) {
                    return { isValid: false, error: this.getTranslation('invalidGeometryType') };
                }

                // Basic coordinate validation
                try {
                    this.validateCoordinates(geometry.coordinates, geometry.type);
                } catch (error) {
                    return { isValid: false, error: error.message };
                }

                return { isValid: true };
            }

            validateCoordinates(coordinates, type) {
                if (!Array.isArray(coordinates)) {
                    throw new Error(this.getTranslation('coordinatesMustBeArray'));
                }

                switch (type) {
                    case 'Point':
                        if (coordinates.length < 2 || coordinates.length > 3) {
                            throw new Error(this.getTranslation('invalidPointCoordinates'));
                        }
                        if (typeof coordinates[0] !== 'number' || typeof coordinates[1] !== 'number') {
                            throw new Error(this.getTranslation('invalidCoordinateValues'));
                        }
                        break;
                    case 'LineString':
                        if (coordinates.length < 2) {
                            throw new Error(this.getTranslation('invalidLineStringCoordinates'));
                        }
                        for (let i = 0; i < coordinates.length; i++) {
                            const coord = coordinates[i];
                            if (!Array.isArray(coord) || coord.length < 2 || coord.length > 3) {
                                throw new Error(this.getTranslation('invalidCoordinateArray'));
                            }
                        }
                        break;
                    case 'Polygon':
                        if (coordinates.length === 0) {
                            throw new Error(this.getTranslation('invalidPolygonCoordinates'));
                        }
                        for (let i = 0; i < coordinates.length; i++) {
                            const ring = coordinates[i];
                            if (!Array.isArray(ring) || ring.length < 4) {
                                throw new Error(this.getTranslation('invalidPolygonRing'));
                            }
                        }
                        break;
                    case 'MultiPoint':
                    case 'MultiLineString':
                    case 'MultiPolygon':
                        if (coordinates.length === 0) {
                            throw new Error(this.getTranslation('invalidMultiGeometryCoordinates'));
                        }
                        break;
                }
            }

            handleJSONError(error, text) {
                const errorMsg = error.message;
                let line = 1, column = 1;

                // Try to extract line and column information
                const match = errorMsg.match(/at position (\d+)/);
                if (match) {
                    const position = parseInt(match[1]);
                    // Count lines more efficiently without creating array
                    let lineCount = 1;
                    let lastNewlinePos = -1;
                    for (let i = 0; i < position && i < text.length; i++) {
                        if (text[i] === '\n') {
                            lineCount++;
                            lastNewlinePos = i;
                        }
                    }
                    line = lineCount;
                    column = position - lastNewlinePos;
                }

                const detailedError = `JSON Syntax Error at line ${line}, column ${column}: ${errorMsg}`;
                this.showError(detailedError);

                // Try to suggest fixes
                this.suggestFixes(text, error);
            }

            suggestFixes(text, error) {
                const suggestions = [];
                const errorMsg = error.message.toLowerCase();

                if (errorMsg.includes('unexpected token')) {
                    suggestions.push('Check for missing commas between object properties or array elements');
                    suggestions.push('Verify all quotes are properly closed');
                    suggestions.push('Remove any trailing commas');
                }

                if (errorMsg.includes('unexpected end')) {
                    suggestions.push('Check for missing closing brackets ] or braces }');
                    suggestions.push('Verify all opening brackets/braces have matching closing ones');
                }

                if (suggestions.length > 0) {
                    const suggestionHtml = '<div class="warning-message"><strong>Suggestions:</strong><ul>' +
                        suggestions.map(s => `<li>${s}</li>`).join('') + '</ul></div>';
                    document.getElementById('errorMessages').innerHTML += suggestionHtml;
                }
            }

            autoFixJSON() {
                const editor = document.getElementById('jsonEditor');
                const originalText = editor.value.trim();
                
                if (!originalText) {
                    this.showError(this.getTranslation('pleaseProvideJSON'));
                    return;
                }

                // Try to fix the JSON
                const fixedText = this.fixCommonJSONIssues(originalText);
                
                // Validate the fixed result
                try {
                    const parsed = JSON.parse(fixedText);
                    // If parsing succeeds, format the JSON and update the editor
                    editor.value = JSON.stringify(parsed, null, 2);
                    // Clear fixedText from memory
                    this.updateLineNumbers();
                    this.validateJSON();
                    this.showSuccess(this.getTranslation('autoFixSuccess'));
                } catch (error) {
                    // If parsing fails, keep original text and show error
                    this.showError(this.getTranslation('autoFixFailed'));
                    console.warn('Auto-fix failed. Original text preserved. Error:', error.message);
                }
            }

            fixCommonJSONIssues(text) {
                // Step 1: Fix missing commas (must be first, before whitespace cleanup)
                text = this.fixMissingCommas(text);
                
                // Step 2: Basic cleanup (conservative)
                text = this.cleanupWhitespace(text);
                
                // Step 3: Fix quotes (conservative)
                text = this.fixQuotesAndSyntax(text);
                
                // Step 4: Fix unquoted keys (conservative)
                text = this.fixUnquotedKeys(text);
                
                // Step 5: Fix trailing commas (conservative)
                text = this.fixTrailingCommas(text);
                
                // Step 6: Elaborate bracket balancing
                text = this.balanceBracketsElaborate(text);
                
                // Step 7: Final cleanup (conservative)
                text = this.finalCleanup(text);
                
                return text;
            }

            cleanupWhitespace(text) {
                // Optimize by chaining all regex replacements in one pass where possible
                return text
                    .replace(/\s+/g, ' ')
                    .replace(/\s*([{}[\],:])\s*/g, '$1')
                    .replace(/:\s*"/g, ':"')
                    .replace(/"\s*([,}\]])/g, '"$1');
            }

            fixQuotesAndSyntax(text) {
                // Fix single quotes to double quotes (conservative approach)
                text = text.replace(/(?<!\\)'/g, '"'); // Replace single quotes, but not escaped ones
                
                // Fix smart quotes to regular quotes
                text = text.replace(/[""]/g, '"');
                text = text.replace(/['']/g, '"');
                
                return text;
            }

            fixUnquotedKeys(text) {
                // Fix unquoted property names (more comprehensive pattern)
                text = text.replace(/([{,]\s*)([a-zA-Z_$][a-zA-Z0-9_$]*)\s*:/g, '$1"$2":');
                
                // Fix unquoted keys with dots (like "type": "Feature")
                text = text.replace(/([{,]\s*)([a-zA-Z_$][a-zA-Z0-9_$]*\.[a-zA-Z_$][a-zA-Z0-9_$]*)\s*:/g, '$1"$2":');
                
                // Fix unquoted keys with spaces (should be quoted)
                text = text.replace(/([{,]\s*)([a-zA-Z_$][a-zA-Z0-9_$\s]+)\s*:/g, '$1"$2":');
                
                return text;
            }

            fixTrailingCommas(text) {
                // Remove trailing commas before closing brackets/braces
                text = text.replace(/,(\s*[}\]])/g, '$1');
                
                // Remove trailing commas before closing braces
                text = text.replace(/,(\s*})/g, '$1');
                
                // Remove trailing commas in arrays
                text = text.replace(/,(\s*])/g, '$1');
                
                return text;
            }

            fixMissingCommas(text) {
                // Simple and elegant approach: find patterns where there should be commas
                let result = text;
                
                // Fix missing commas between object properties
                // Pattern: "key":"value" "key":"value" -> "key":"value", "key":"value"
                result = result.replace(/"([^"]*)"\s*:\s*"([^"]*)"\s+"([^"]*)"\s*:/g, '"$1":"$2", "$3":');
                
                // Fix missing commas between object properties with numbers
                // Pattern: "key":123 "key":"value" -> "key":123, "key":"value"
                result = result.replace(/"([^"]*)"\s*:\s*([0-9.-]+)\s+"([^"]*)"\s*:/g, '"$1":$2, "$3":');
                
                // Fix missing commas between array elements
                // Pattern: "value" "value" -> "value", "value"
                result = result.replace(/"([^"]*)"\s+"([^"]*)"\s*([,\]])/g, '"$1", "$2"$3');
                
                // Fix missing commas between numbers in arrays
                // Pattern: 123 456 -> 123, 456
                result = result.replace(/([0-9.-]+)\s+([0-9.-]+)\s*([,\]])/g, '$1, $2$3');
                
                // Generic fix for missing commas between object properties
                // Pattern: } "key": -> }, "key":
                result = result.replace(/\}\s+"([^"]*)"\s*:/g, '}, "$1":');
                
                return result;
            }

            balanceBracketsElaborate(text) {
                const stack = [];
                let inString = false;
                let escapeNext = false;
                
                // First pass: analyze bracket structure
                for (let i = 0; i < text.length; i++) {
                    const char = text[i];
                    
                    if (escapeNext) {
                        escapeNext = false;
                        continue;
                    }
                    
                    if (char === '\\') {
                        escapeNext = true;
                        continue;
                    }
                    
                    if (char === '"') {
                        inString = !inString;
                        continue;
                    }
                    
                    if (inString) continue;
                    
                    if (char === '{' || char === '[') {
                        stack.push(char);
                    } else if (char === '}' || char === ']') {
                        const expected = char === '}' ? '{' : '[';
                        if (stack.length > 0 && stack[stack.length - 1] === expected) {
                            stack.pop();
                        }
                    }
                }
                
                // Build result string only if needed
                let result = text;
                
                // Add missing closing brackets/braces at the end
                if (stack.length > 0) {
                    const closingBrackets = [];
                    for (let i = stack.length - 1; i >= 0; i--) {
                        closingBrackets.push(stack[i] === '{' ? '}' : ']');
                    }
                    result = text + closingBrackets.join('');
                }
                
                // Fix common bracket placement issues
                result = result
                    .replace(/\}\s*\[/g, '},[')
                    .replace(/\]\s*\{/g, '],{')
                    .replace(/\}\s*\{/g, '},{')
                    .replace(/\]\s*\[/g, '],[');
                
                return result;
            }

            // Removed fixGeoJSONSpecificIssues as it was causing issues

            finalCleanup(text) {
                // Remove any remaining problematic characters
                text = text.replace(/\s+/g, ' '); // Final whitespace cleanup
                
                // Ensure proper spacing around brackets
                text = text.replace(/\s*([{}[\]])\s*/g, '$1');
                
                return text.trim();
            }

            formatJSON() {
                const editor = document.getElementById('jsonEditor');
                try {
                    const parsed = JSON.parse(editor.value);
                    editor.value = JSON.stringify(parsed, null, 2);
                    this.updateLineNumbers();
                    this.showSuccess(this.getTranslation('jsonFormattedSuccess'));
                } catch (error) {
                    this.showError(this.getTranslation('cannotFormatInvalidJSON'));
                }
            }

            checkGeometryErrors(feature, index) {
                // Check for various geometry errors and return error descriptions
                const errors = [];
                
                // Check for missing geometry
                if (!feature.geometry) {
                    errors.push(`Feature ${index}: Missing geometry`);
                    return errors;
                }
                
                // Check for invalid geometry object
                if (typeof feature.geometry !== 'object') {
                    errors.push(`Feature ${index}: Invalid geometry object`);
                    return errors;
                }
                
                // Check for missing geometry type
                if (!feature.geometry.type) {
                    errors.push(`Feature ${index}: Missing geometry type`);
                    return errors;
                }
                
                // Check for missing coordinates
                if (!feature.geometry.coordinates) {
                    errors.push(`Feature ${index}: Missing coordinates`);
                    return errors;
                }
                
                // Check coordinates based on geometry type
                const coords = feature.geometry.coordinates;
                const type = feature.geometry.type;
                
                try {
                    switch (type) {
                        case 'Point':
                            if (!Array.isArray(coords) || coords.length < 2) {
                                errors.push(`Feature ${index}: Invalid Point coordinates (need at least [lon, lat])`);
                            }
                            if (!this.isValidCoordinate(coords[0]) || !this.isValidCoordinate(coords[1])) {
                                errors.push(`Feature ${index}: Invalid coordinate values in Point`);
                            }
                            break;
                            
                        case 'LineString':
                            if (!Array.isArray(coords) || coords.length < 2) {
                                errors.push(`Feature ${index}: LineString must have at least 2 points`);
                            } else {
                                for (let i = 0; i < coords.length; i++) {
                                    if (!Array.isArray(coords[i]) || coords[i].length < 2) {
                                        errors.push(`Feature ${index}: Invalid coordinate array depth in LineString`);
                                        break;
                                    }
                                    if (!this.isValidCoordinate(coords[i][0]) || !this.isValidCoordinate(coords[i][1])) {
                                        errors.push(`Feature ${index}: Invalid coordinate values in LineString`);
                                        break;
                                    }
                                }
                            }
                            break;
                            
                        case 'Polygon':
                            if (!Array.isArray(coords) || coords.length === 0) {
                                errors.push(`Feature ${index}: Polygon must have at least one ring`);
                            } else {
                                for (let i = 0; i < coords.length; i++) {
                                    const ring = coords[i];
                                    if (!Array.isArray(ring) || ring.length < 4) {
                                        errors.push(`Feature ${index}: Polygon ring ${i} must have at least 4 points`);
                                        break;
                                    }
                                    for (let j = 0; j < ring.length; j++) {
                                        if (!Array.isArray(ring[j]) || ring[j].length < 2) {
                                            errors.push(`Feature ${index}: Invalid coordinate array depth in Polygon ring ${i}`);
                                            break;
                                        }
                                        if (!this.isValidCoordinate(ring[j][0]) || !this.isValidCoordinate(ring[j][1])) {
                                            errors.push(`Feature ${index}: Invalid coordinate values in Polygon ring ${i}`);
                                            break;
                                        }
                                    }
                                }
                            }
                            break;
                            
                        case 'MultiPoint':
                            if (!Array.isArray(coords) || coords.length === 0) {
                                errors.push(`Feature ${index}: MultiPoint must have at least one point`);
                            } else {
                                for (let i = 0; i < coords.length; i++) {
                                    if (!Array.isArray(coords[i]) || coords[i].length < 2) {
                                        errors.push(`Feature ${index}: Invalid coordinate array depth in MultiPoint`);
                                        break;
                                    }
                                    if (!this.isValidCoordinate(coords[i][0]) || !this.isValidCoordinate(coords[i][1])) {
                                        errors.push(`Feature ${index}: Invalid coordinate values in MultiPoint`);
                                        break;
                                    }
                                }
                            }
                            break;
                            
                        case 'MultiLineString':
                            if (!Array.isArray(coords) || coords.length === 0) {
                                errors.push(`Feature ${index}: MultiLineString must have at least one LineString`);
                            } else {
                                for (let i = 0; i < coords.length; i++) {
                                    const linestring = coords[i];
                                    if (!Array.isArray(linestring) || linestring.length < 2) {
                                        errors.push(`Feature ${index}: MultiLineString line ${i} must have at least 2 points`);
                                        break;
                                    }
                                }
                            }
                            break;
                            
                        case 'MultiPolygon':
                            if (!Array.isArray(coords) || coords.length === 0) {
                                errors.push(`Feature ${index}: MultiPolygon must have at least one Polygon`);
                            } else {
                                for (let i = 0; i < coords.length; i++) {
                                    const polygon = coords[i];
                                    if (!Array.isArray(polygon) || polygon.length === 0) {
                                        errors.push(`Feature ${index}: MultiPolygon polygon ${i} must have at least one ring`);
                                        break;
                                    }
                                    for (let j = 0; j < polygon.length; j++) {
                                        const ring = polygon[j];
                                        if (!Array.isArray(ring) || ring.length < 4) {
                                            errors.push(`Feature ${index}: MultiPolygon polygon ${i} ring ${j} must have at least 4 points`);
                                            break;
                                        }
                                    }
                                }
                            }
                            break;
                    }
                } catch (error) {
                    errors.push(`Feature ${index}: Error checking geometry - ${error.message}`);
                }
                
                return errors;
            }

            isValidCoordinate(value) {
                // Check if a coordinate value is valid (not null, not NaN, not Infinity)
                return typeof value === 'number' && 
                       !isNaN(value) && 
                       isFinite(value);
            }

            analyzeData() {
                if (!this.rawData) return;

                let featureCount = 0;
                let polygonCount = 0;
                let multiPolygonCount = 0;
                let pointCount = 0;
                const properties = new Set();
                
                // Clear errors before analyzing
                this.errors = [];

                // Normalize to FeatureCollection format for analysis
                const features = this.extractFeatures(this.rawData);
                
                for (let i = 0; i < features.length; i++) {
                    const feature = features[i];
                    featureCount++;
                    
                    // Check for geometry errors
                    const geometryErrors = this.checkGeometryErrors(feature, i);
                    if (geometryErrors.length > 0) {
                        this.errors.push(...geometryErrors);
                    }
                    
                    if (feature.geometry) {
                        const geoType = feature.geometry.type;
                        if (geoType === 'Polygon') {
                            polygonCount++;
                        } else if (geoType === 'MultiPolygon') {
                            multiPolygonCount++;
                        } else if (geoType === 'Point') {
                            pointCount++;
                        }
                    }

                    if (feature.properties) {
                        for (const key in feature.properties) {
                            properties.add(key);
                        }
                    }
                }

                this.updateStats(featureCount, polygonCount, multiPolygonCount, pointCount, this.errors.length);
                this.setupPropertyMapping(Array.from(properties));
                document.getElementById('fileStats').classList.remove('hidden');
                document.getElementById('propertyMapping').classList.remove('hidden');
                
                // Log errors to console for debugging
                if (this.errors.length > 0) {
                    console.warn('Geometry errors found:', this.errors);
                }
            }

            updateStats(features, polygons, multiPolygons, points, errors) {
                document.getElementById('featureCount').textContent = features;
                document.getElementById('polygonCount').textContent = polygons;
                document.getElementById('multiPolygonCount').textContent = multiPolygons;
                document.getElementById('pointCount').textContent = points;
                document.getElementById('errorCount').textContent = errors;
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            setupPropertyMapping(existingProperties) {
                const predefinedFields = ['ProducerName', 'ProductionPlace', 'Area', 'ProducerCountry', 'AdditionalInfo'];
                const propertyList = document.getElementById('propertyList');
                propertyList.innerHTML = '';

                existingProperties.forEach(prop => {
                    const escapedProp = this.escapeHtml(prop);
                    const row = document.createElement('div');
                    row.className = 'property-row';
                    row.innerHTML = `
                        <input type="text" value="${escapedProp}" readonly data-original-property="${escapedProp}">
                        <span>‚Üí</span>
                        <select>
                            <option value="__leave_as_is__" selected>${this.getTranslation('leaveAsIs')}</option>
                            <option value="">${this.getTranslation('discardPropertyInformation')}</option>
                            ${predefinedFields.map(field => 
                                `<option value="${this.escapeHtml(field)}" ${field === prop ? 'selected' : ''}>${this.escapeHtml(field)}</option>`
                            ).join('')}
                            <option value="custom">${this.getTranslation('customFieldName')}</option>
                        </select>
                        <input type="text" placeholder="${this.escapeHtml(this.getTranslation('customFieldName'))}" style="display: none;" class="custom-field-input">
                    `;
                    propertyList.appendChild(row);

                    // Store the original property name on the row element for later retrieval
                    row.dataset.originalProperty = prop;

                    const select = row.querySelector('select');
                    const customInput = row.querySelector('.custom-field-input');
                    
                    select.addEventListener('change', (e) => {
                        if (e.target.value === 'custom') {
                            customInput.style.display = 'block';
                            customInput.focus();
                        } else {
                            customInput.style.display = 'none';
                        }
                    });
                });
            }

            addStaticField() {
                const staticFieldsList = document.getElementById('staticFieldsList');
                const predefinedFields = ['ProducerName', 'ProductionPlace', 'Area', 'ProducerCountry', 'AdditionalInfo'];
                
                const row = document.createElement('div');
                row.className = 'static-field-row';
                row.innerHTML = `
                    <select>
                        <option value="">${this.escapeHtml(this.getTranslation('selectField'))}</option>
                        ${predefinedFields.map(field => `<option value="${this.escapeHtml(field)}">${this.escapeHtml(field)}</option>`).join('')}
                        <option value="custom">${this.escapeHtml(this.getTranslation('customField'))}</option>
                    </select>
                    <input type="text" placeholder="${this.escapeHtml(this.getTranslation('customFieldName'))}" style="display: none;" class="custom-name-input">
                    <input type="text" placeholder="${this.escapeHtml(this.getTranslation('staticValue'))}" class="static-value-input">
                    <button type="button" onclick="this.parentElement.remove()">
                        üóëÔ∏è
                    </button>
                `;
                staticFieldsList.appendChild(row);

                const select = row.querySelector('select');
                const customInput = row.querySelector('.custom-name-input');
                
                select.addEventListener('change', (e) => {
                    if (e.target.value === 'custom') {
                        customInput.style.display = 'block';
                        customInput.focus();
                    } else {
                        customInput.style.display = 'none';
                    }
                });
            }

            extractFeatures(data) {
                if (data.type === 'FeatureCollection') {
                    // Return direct reference to avoid copying
                    return data.features || [];
                } else if (data.type === 'Feature') {
                    return [data];
                } else if (data.type && ['Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon'].includes(data.type)) {
                    // Raw geometry object
                    return [{
                        type: 'Feature',
                        geometry: data,
                        properties: {}
                    }];
                } else if (Array.isArray(data)) {
                    // Array of features or geometries - flatten recursively
                    const features = [];
                    for (let i = 0; i < data.length; i++) {
                        const extracted = this.extractFeatures(data[i]);
                        for (let j = 0; j < extracted.length; j++) {
                            features.push(extracted[j]);
                        }
                    }
                    return features;
                }

                return [];
            }

            async processGeoJSON() {
                if (!this.rawData) {
                    this.showError(this.getTranslation('noValidDataToProcess'));
                    return;
                }

                this.showLoading(true);
                this.updateProgress(0);

                try {
                    // Collect property mappings
                    this.collectPropertyMappings();
                    this.collectStaticFields();
                    this.updateProgress(10);

                    // Extract features
                    const features = this.extractFeatures(this.rawData);
                    const totalFeatures = features.length;
                    this.updateProgress(20);

                    // Process features in batches to allow browser to breathe
                    const processedFeatures = [];
                    const batchSize = 1000;
                    
                    for (let i = 0; i < totalFeatures; i += batchSize) {
                        const batchEnd = Math.min(i + batchSize, totalFeatures);
                        
                        // Process this batch
                        for (let j = i; j < batchEnd; j++) {
                            const feature = features[j];
                            
                            // Split MultiPolygons if requested
                            if (document.getElementById('splitMultiPolygons').checked && 
                                feature.geometry && feature.geometry.type === 'MultiPolygon') {
                                const splitFeatures = this.splitMultiPolygon(feature);
                                processedFeatures.push(...splitFeatures);
                            } else {
                                processedFeatures.push(this.processFeature(feature));
                            }
                        }
                        
                        // Update progress
                        this.updateProgress(20 + (batchEnd / totalFeatures) * 60);
                        
                        // Yield to browser to prevent blocking
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }

                    // Create final GeoJSON
                    this.processedData = {
                        type: 'FeatureCollection',
                        features: processedFeatures
                    };

                    this.updateProgress(90);
                    
                    // Automatically download the processed file
                    this.downloadResult();
                    
                    this.updateProgress(100);
                    this.showSuccess(this.getTranslation('successfullyProcessed') + processedFeatures.length + this.getTranslation('featuresCount'));
                    
                } catch (error) {
                    this.showError(this.getTranslation('processingFailed') + error.message);
                } finally {
                    this.showLoading(false);
                }
            }

            collectPropertyMappings() {
                this.propertyMappings.clear();
                this.discardedProperties = new Set(); // Track discarded properties
                
                const propertyRows = document.querySelectorAll('#propertyList .property-row');
                propertyRows.forEach(row => {
                    // Get the original (unescaped) property name from the data attribute
                    const sourceField = row.dataset.originalProperty;
                    const select = row.querySelector('select');
                    const customInput = row.querySelector('.custom-field-input');
                    
                    let targetField = select.value;
                    
                    if (targetField === '__leave_as_is__') {
                        // Leave as is - map property to itself
                        this.propertyMappings.set(sourceField, sourceField);
                    } else if (targetField === 'custom' && customInput.value.trim()) {
                        targetField = customInput.value.trim();
                        this.propertyMappings.set(sourceField, targetField);
                    } else if (targetField && targetField !== '') {
                        this.propertyMappings.set(sourceField, targetField);
                    } else {
                        // If targetField is empty, mark this property as discarded
                        this.discardedProperties.add(sourceField);
                    }
                });
            }

            collectStaticFields() {
                this.staticFields.clear();
                
                const staticRows = document.querySelectorAll('#staticFieldsList .static-field-row');
                staticRows.forEach(row => {
                    const select = row.querySelector('select');
                    const customInput = row.querySelector('.custom-name-input');
                    const valueInput = row.querySelector('.static-value-input');
                    
                    let fieldName = select.value;
                    if (fieldName === 'custom' && customInput.value.trim()) {
                        fieldName = customInput.value.trim();
                    }
                    
                    if (fieldName && valueInput.value.trim()) {
                        this.staticFields.set(fieldName, valueInput.value.trim());
                    }
                });
            }

            splitMultiPolygon(feature) {
                const multiPolygon = feature.geometry;
                const splitFeatures = [];

                multiPolygon.coordinates.forEach((polygonCoords, index) => {
                    const newFeature = {
                        type: 'Feature',
                        geometry: {
                            type: 'Polygon',
                            coordinates: polygonCoords
                        },
                        properties: feature.properties
                    };
                    
                    // Add index to distinguish split features
                    if (feature.properties && feature.properties.id) {
                        newFeature.properties = Object.assign({}, feature.properties, {
                            id: `${feature.properties.id}_${index + 1}`
                        });
                    }
                    
                    splitFeatures.push(this.processFeature(newFeature));
                });

                return splitFeatures;
            }

            processFeature(feature) {
                // Build properties object more efficiently
                const properties = {};

                // Apply property mappings
                if (feature.properties) {
                    for (const key in feature.properties) {
                        // Skip discarded properties
                        if (this.discardedProperties && this.discardedProperties.has(key)) {
                            continue;
                        }
                        const mappedKey = this.propertyMappings.get(key) || key;
                        properties[mappedKey] = feature.properties[key];
                    }
                }

                // Apply static fields
                this.staticFields.forEach((value, key) => {
                    properties[key] = value;
                });

                // Validate geometry if requested
                let geometry = feature.geometry;
                if (document.getElementById('validateGeometry').checked) {
                    geometry = this.validateAndFixGeometry(geometry);
                }

                return {
                    type: 'Feature',
                    geometry: geometry,
                    properties: properties
                };
            }

            roundCoordinate(coord, decimals = 6) {
                // Round a single coordinate value to specified decimal places
                const factor = Math.pow(10, decimals);
                return Math.round(coord * factor) / factor;
            }

            roundCoordinates(coordinates, type) {
                // Round coordinates based on geometry type
                if (!coordinates) return coordinates;

                switch (type) {
                    case 'Point':
                        // [lon, lat] or [lon, lat, elevation]
                        return coordinates.map(coord => this.roundCoordinate(coord));
                    
                    case 'LineString':
                    case 'MultiPoint':
                        // [[lon, lat], [lon, lat], ...]
                        return coordinates.map(coord => 
                            coord.map(c => this.roundCoordinate(c))
                        );
                    
                    case 'Polygon':
                    case 'MultiLineString':
                        // [[[lon, lat], [lon, lat], ...], ...]
                        return coordinates.map(ring =>
                            ring.map(coord => coord.map(c => this.roundCoordinate(c)))
                        );
                    
                    case 'MultiPolygon':
                        // [[[[lon, lat], [lon, lat], ...], ...], ...]
                        return coordinates.map(polygon =>
                            polygon.map(ring =>
                                ring.map(coord => coord.map(c => this.roundCoordinate(c)))
                            )
                        );
                    
                    default:
                        return coordinates;
                }
            }

            calculateSignedArea(ring) {
                // Calculate signed area of a ring using the Shoelace formula
                // Positive area = counterclockwise, Negative area = clockwise
                if (!ring || ring.length < 3) return 0;
                
                let area = 0;
                for (let i = 0; i < ring.length - 1; i++) {
                    const [x1, y1] = ring[i];
                    const [x2, y2] = ring[i + 1];
                    area += (x2 - x1) * (y2 + y1);
                }
                return area;
            }

            closeRing(ring) {
                // Ensure ring is closed (first and last coordinates match)
                if (!ring || ring.length === 0) return ring;
                
                const first = ring[0];
                const last = ring[ring.length - 1];
                
                if (first[0] !== last[0] || first[1] !== last[1]) {
                    ring.push([first[0], first[1]]);
                }
                
                return ring;
            }

            normalizeRingWindingOrder(ring, isExterior) {
                // Normalize ring winding order
                // Exterior rings: counterclockwise (positive area)
                // Holes: clockwise (negative area)
                if (!ring || ring.length < 3) return ring;
                
                const signedArea = this.calculateSignedArea(ring);
                const isCounterClockwise = signedArea > 0;
                
                // If exterior ring should be CCW but is CW, or hole should be CW but is CCW, reverse
                if ((isExterior && !isCounterClockwise) || (!isExterior && isCounterClockwise)) {
                    // Reverse the ring, but keep last point as duplicate of first after reversal
                    const reversed = ring.slice(0, -1).reverse();
                    reversed.push([reversed[0][0], reversed[0][1]]);
                    return reversed;
                }
                
                return ring;
            }

            fixPolygonGeometry(coordinates) {
                // Fix a Polygon's coordinates: close rings and normalize winding order
                if (!coordinates || coordinates.length === 0) return coordinates;
                
                for (let i = 0; i < coordinates.length; i++) {
                    let ring = coordinates[i];
                    
                    // Close the ring
                    ring = this.closeRing(ring);
                    
                    // Normalize winding order (first ring is exterior, others are holes)
                    ring = this.normalizeRingWindingOrder(ring, i === 0);
                    
                    coordinates[i] = ring;
                }
                
                return coordinates;
            }

            validateAndFixGeometry(geometry) {
                if (!geometry || !geometry.coordinates) {
                    return geometry;
                }

                // Basic validation and fixes
                try {
                    if (geometry.type === 'Polygon' && geometry.coordinates) {
                        geometry.coordinates = this.fixPolygonGeometry(geometry.coordinates);
                    } else if (geometry.type === 'MultiPolygon' && geometry.coordinates) {
                        // Fix each polygon in the MultiPolygon
                        for (let i = 0; i < geometry.coordinates.length; i++) {
                            geometry.coordinates[i] = this.fixPolygonGeometry(geometry.coordinates[i]);
                        }
                    }

                    // Round coordinates if requested
                    if (document.getElementById('roundCoordinates').checked) {
                        geometry.coordinates = this.roundCoordinates(geometry.coordinates, geometry.type);
                    }
                } catch (error) {
                    console.warn('Geometry validation failed:', error);
                }

                return geometry;
            }

            downloadResult() {
                if (!this.processedData) {
                    this.showError(this.getTranslation('noProcessedDataToDownload'));
                    return;
                }

                // Check if whitespace removal is requested
                const removeWhitespace = document.getElementById('removeWhitespace').checked;
                const jsonString = removeWhitespace 
                    ? JSON.stringify(this.processedData) 
                    : JSON.stringify(this.processedData, null, 2);

                const blob = new Blob([jsonString], {
                    type: 'application/json'
                });
                
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'processed_EUDR_file.geojson';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // Clear processed data after download to free memory
                this.processedData = null;
            }

            reset() {
                // Clear data
                this.rawData = null;
                this.processedData = null;
                this.errors = [];
                this.warnings = [];
                this.staticFields.clear();
                this.propertyMappings.clear();
                this.discardedProperties.clear();

                // Clear editor and update line numbers
                const editor = document.getElementById('jsonEditor');
                editor.value = '';
                this.updateLineNumbers();
                
                // Clear error messages
                document.getElementById('errorMessages').innerHTML = '';
                
                // Hide sections
                document.getElementById('editorSection').classList.add('hidden');
                document.getElementById('fileStats').classList.add('hidden');
                document.getElementById('staticFields').classList.add('hidden');
                document.getElementById('propertyMapping').classList.add('hidden');
                document.getElementById('processingOptions').classList.add('hidden');
                document.getElementById('actionButtons').classList.add('hidden');
                document.getElementById('progressBar').classList.add('hidden');
                
                // Clear dynamic content
                document.getElementById('staticFieldsList').innerHTML = '';
                document.getElementById('propertyList').innerHTML = '';
                
                // Reset file input
                document.getElementById('fileInput').value = '';
                
                // Reset editor container styling
                document.getElementById('jsonEditorContainer').classList.remove('has-error');
                editor.classList.remove('has-error');
                
                // Clear any validation timeout
                if (this.validateTimeout) {
                    clearTimeout(this.validateTimeout);
                }
            }

            handleEditorChange() {
                // Update line numbers immediately on change
                this.updateLineNumbers();
                
                // Auto-validate on change with debounce
                clearTimeout(this.validateTimeout);
                this.validateTimeout = setTimeout(() => {
                    this.validateJSON();
                }, 1000);
            }

            showError(message) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-message';
                errorDiv.innerHTML = `‚ö†Ô∏è ${message}`;
                
                const container = document.getElementById('errorMessages');
                container.innerHTML = '';
                container.appendChild(errorDiv);
            }

            showSuccess(message) {
                const successDiv = document.createElement('div');
                successDiv.className = 'success-message';
                successDiv.innerHTML = `‚úîÔ∏è ${message}`;
                
                const container = document.getElementById('errorMessages');
                container.innerHTML = '';
                container.appendChild(successDiv);
            }

            getTranslation(key) {
                return translations[this.currentLanguage][key] || key;
            }

            showWarning(message) {
                const warningDiv = document.createElement('div');
                warningDiv.className = 'warning-message';
                warningDiv.innerHTML = `‚ö†Ô∏è ${message}`;
                
                const container = document.getElementById('errorMessages');
                container.appendChild(warningDiv);
            }

            clearErrors() {
                document.getElementById('errorMessages').innerHTML = '';
            }

            showLoading(show) {
                const overlay = document.getElementById('loadingOverlay');
                if (show) {
                    overlay.classList.add('show');
                }
                else {
                    overlay.classList.remove('show');
                }
            }

            updateProgress(percent) {
                const progressBar = document.getElementById('progressBar');
                const progressFill = document.getElementById('progressFill');
                
                if (percent > 0) {
                    progressBar.classList.remove('hidden');
                    progressFill.style.width = percent + '%';
                    
                    if (percent >= 100) {
                        setTimeout(() => {
                            progressBar.classList.add('hidden');
                        }, 1000);
                    }
                }
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
        });

        // Main app initialization
        function initializeApp() {
            const converter = new GeoJSONConverter();
            
            // Force clear editor on page load/refresh to prevent browser retention
            const editor = document.getElementById('jsonEditor');
            if (editor) {
                editor.value = '';
                converter.updateLineNumbers();
            }
        }


    </script>
</body>
</html>